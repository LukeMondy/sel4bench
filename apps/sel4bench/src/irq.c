/*
 * Copyright 2014, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(NICTA_GPL)
 */

#include "benchmark.h"
#include "processing.h"
#include "timing.h"

#include <stdio.h>

#include <sel4platsupport/timer.h>
#include <utils/time.h>

#include <sel4bench/kernel_logging.h>
#include <sel4bench/logging.h>

#define N_INTERRUPTS 500
#define N_IGNORED 10

/* Interrupt every 10 ms */
#define INTERRUPT_PERIOD_NS (10 * NS_IN_MS)

#define TRACE_POINT_OVERHEAD 0
#define TRACE_POINT_IRQ_PATH_START 1
#define TRACE_POINT_IRQ_PATH_END 2

/* Arrays to hold log data and metadata */
static kernel_log_entry_t kernel_log[KERNEL_MAX_NUM_LOG_ENTRIES];
static ccnt_t kernel_log_data[KERNEL_MAX_NUM_LOG_ENTRIES];
static unsigned int offsets[CONFIG_MAX_NUM_TRACE_POINTS];
static unsigned int sizes[CONFIG_MAX_NUM_TRACE_POINTS];

static void
print_result(bench_result_t *result)
{
    printf("min\tmax\tmean\tvariance\tstddev\tstddev %%\n");

    printf(CCNT_FORMAT"\t", result->min);
    printf(CCNT_FORMAT"\t", result->max);
    printf("%.2lf\t", result->mean);
    printf("%.2lf\t", result->variance);
    printf("%.2lf\t", result->stddev);
    printf("%.0lf%%\n", result->stddev_pc);
}

void
irq_benchmarks_new(struct env* env) {

    vka_object_t timer_notification_object = {0};

    /* Set up timer as a source of interrupts */
    if (vka_alloc_notification(&env->vka, &timer_notification_object) != 0) {
        ZF_LOGF("Failed to allocate async endpoint\n");
    }
    seL4_CPtr timer_notification = timer_notification_object.cptr;

    seL4_timer_t *timer = sel4platsupport_get_default_timer(
                            &env->vka, &env->vspace, 
                            &env->simple, timer_notification);
    if (timer == NULL) {
        ZF_LOGF("Failed to access timer driver\n");
    }

    if (timer_periodic(timer->timer, INTERRUPT_PERIOD_NS) != 0) {
        ZF_LOGF("Failed to configure timer\n");
    }

    if (timer_start(timer->timer) != 0) {
        ZF_LOGF("Failed to start timer\n");
    }

    timing_init();

    /* Record tracepoints for irq path */
    kernel_logging_reset_log();
    for (int i = 0; i < N_INTERRUPTS; ++i) {
        seL4_Wait(timer_notification, NULL);
        /* Each time an interrupt is processed by the kernel,
         * several tracepoints are invoked in the kernel which record
         * cycle counts between pairs of points.
         *
         * TRACE_POINT_OVERHEAD counts the cycles consumed by starting
         * and immediately stopping a tracepoint.
         * TRACE_POINT_IRQ_PATH_START and TRACE_POINT_IRQ_PATH_END each
         * count cycles for part of the IRQ path (from the point where
         * an interrupt is received by the kernel to the return to user
         * mode). Multiple tracepoints are used to record cycle counts
         * only when a specific path between these two points is followed.
         */
        sel4_timer_handle_single_irq(timer);
    }
    kernel_logging_finalize_log();

    timing_destroy();

    if (timer_stop(timer->timer) != 0) {
        ZF_LOGF("Failed to stop timer\n");
    }

    /* Extract data from kernel */
    unsigned int n = kernel_logging_sync_log(kernel_log, KERNEL_MAX_NUM_LOG_ENTRIES);

    /* Sort and group data by tracepoints. A stable sort is used so the first N_IGNORED
     * results of each tracepoint can be ignored, as this keeps the data in chronological
     * order.
     */
    logging_stable_sort_log(kernel_log, n);
    logging_group_log_by_key(kernel_log, n, sizes, offsets, CONFIG_MAX_NUM_TRACE_POINTS);

    /* Copy the cycle counts into a separate array to simplify further processing */
    for (int i = 0; i < n; ++i) {
        kernel_log_data[i] = kernel_logging_entry_get_data(&kernel_log[i]);
    }

    /* Process log entries generated by an "empty" tracepoint, which recorded
     * the number of cycles between starting a tracepoint and stopping it
     * immediately afterwards. This will determine the overhead introduced by
     * using tracepoints.
     */
    int n_overhead_data = sizes[TRACE_POINT_OVERHEAD] - N_IGNORED;
    if (n_overhead_data <= 0) {
        ZF_LOGF("Insufficient data recorded. Was the kernel built with the relevant tracepoints?\n");
    }

    ccnt_t *overhead_data = &kernel_log_data[offsets[TRACE_POINT_OVERHEAD] + N_IGNORED];
    bench_result_t overhead_result = process_result(overhead_data, n_overhead_data, NULL);

    /* The results of the IRQ path benchmark are split over multiple tracepoints.
     * A new buffer is allocated to store the amalgamated results. */
    int n_data = sizes[TRACE_POINT_IRQ_PATH_START] - N_IGNORED;
    if (n_data <= 0) {
        ZF_LOGF("Insufficient data recorded. Was the kernel built with the relevant tracepoints?\n");
    }

    ccnt_t *data = (ccnt_t*)malloc(sizeof(ccnt_t) * n_data);
    if (data == NULL) {
        ZF_LOGF("Failed to allocate memory\n");
    }

    /* Add the results from the IRQ path tracepoints to get the total IRQ path cycle counts.
     * The average overhead is subtracted from each cycle count (doubled as there are 2
     * tracepoints) to account for overhead added to the cycle counts by use of tracepoints.
     */
    ccnt_t *starts = &kernel_log_data[offsets[TRACE_POINT_IRQ_PATH_START] + N_IGNORED];
    ccnt_t *ends = &kernel_log_data[offsets[TRACE_POINT_IRQ_PATH_END] + N_IGNORED];
    for (int i = 0; i < n_data; ++i) {
        data[i] = starts[i] + ends[i] - (overhead_result.mean * 2);
    }

    printf("Ignoring first %d records.\n\n", N_IGNORED);

    printf("----------------------------------------\n");
    printf("Tracepoint Overhead (%d samples)\n", n_overhead_data);
    printf("----------------------------------------\n");
    bench_result_t result = process_result(overhead_data, n_overhead_data, NULL);
    print_result(&result);
    printf("\n");

    printf("----------------------------------------\n");
    printf("IRQ Path Cycle Count (accounting for overhead) (%d samples)\n", n_data);
    printf("----------------------------------------\n");
    result = process_result(data, n_data, NULL);
    print_result(&result);
    printf("\n");

    free(data);
}
